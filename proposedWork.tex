\documentclass[proposal.tex]{subfiles} 


\begin{document}

%-----------------------------------------------------------------------------
\section{Proposed Work}\label{sect:proposedWork}
%-----------------------------------------------------------------------------
\subsection{Current Work}
\paragraph{}
There have been several attempts at embedding \progLang{Prolog} into \progLang{Haskell} , a few shortcomings are very clear,

\begin{enumerate}
\item Only two embeddings exist, one of them is old and made for \texttt{\bfseries{hugs}} a functional programming system based on the \progLang{
Haskell 98} specification. It is complex and also lacks a lot of \progLang{Prolog} like features including \textit{cuts, fails, assert} among others. The second 
one is based off the first one to make it simple but it loses the variable search strategy support which allows the programmer to choose the manner in which a solution is produced. 

\item The papers that try to take the above further are also few in number and do not have any implementations with the proposed 
concepts. Moreover, none of them are complete and most lack many practical parts of \progLang{Prolog}.

\item Libraries, a few exist, most are old and are not currently maintained or updated. Many provide only a shell through which one has to do all the work, 
which is synonymous with the embeddings mentioned above. Some are far more feature rich than others that is with some practical \progLang{Prolog} 
concepts, but are not complete.

\item Moreover, none of the above have full list support that exist in \progLang{Prolog}.
\end{enumerate}

\par And as far as the idea of merging paradigms goes, it is not the main focus of this thesis and can be more of an "add-on". A handful of crossover hybrid 
languages based on \progLang{Haskell} exist, \progLang{Curry} \cite{website:curry} being the prominent one. Moving away from \progLang{Haskell} 
and exploring other languages from different paradigms, a respectable number of crossover implementations exist but again most of them have faded out.   

\par As discussed in the sections above, either an embedding or an integration approach is taken up for programming languages to work together. 
So, there is either a very shallow approach that does not utilise the constructs available in the host language and results in a mere translation of the 
characteristics, or the other is a fairly complex process which results in tackling the conflicting nature of different programming paradigms and 
languages, resulting in a toned-down  compromised language that takes advantages of neither paradigms. Mostly the trend is to build a library for 
extension to replicate the features as an add on.       

\subsection{Contributions}
\paragraph{}
Taking into consideration above, there is quite some room for improvement and additions. Moving onto what this thesis shall explore, first thing's first a 
complete, fully functional library which comes close to a \progLang{Prolog} like language and has practical abilities to carry out real-world tasks. They 
include predicates like \textit{cut, assert, fail, setOf, bagOf} among others. This would form the first stage of the implementation. Secondly, exploring 
aspects such as\textit{assert} and database capabilities. A third question to address is the accommodation of input and output, specifically dealing with 
the \textit{IO Monad} in \progLang{Haskell} with \progLang{Prolog} \textit{IO}. Moreover, \progLang{Prolog} is an untyped language which allows lists 
with elements of different types to be created. Something like this is not by default in \progLang{Haskell}. Hence syntactic support for the same is the next 
question to address. Furthermore, experimenting with how programs expressed with same declarative meaning differ operationally. Lastly, how would 
characteristics of hybrid languages fit into and play a role in an embedded setting.  

%\texttt{\bfseries{write a paragraph}}
\begin{comment}
\begin{enumerate}
\item Create a \textsc{Prolog} library which comes the closest to a complete \textsc{Prolog} like Language, not only the Declarative concepts but 
also a lot of Practical concepts like cuts, assert, fail, setOf, bagOf among others.

\item Do away with the shell approach. One must be able to write a program just the way one can write a \textsc{Haskell} program and the 
goal is passed as a parameter to the main function and the result is achieved by running it. 

\item Moreover, make an attempt to add some features which are related to Functional Logic Programming Languages, like narrowing 
and residuation among others.      

\item Furthermore, adding or adjusting \textsc{Prolog} IO into the \textsc{Haskell} IO Monad.

\item Translating a \textsc{Prolog} program into a \textsc{Haskell} program, for example two programs with same declarative meaning but different 
computational complexities in \textsc{Prolog} translated into \textsc{Haskell}. (Something similar is there in a paper called Higher Order 
Transformation of Logic Programs)

\item Tackling Translation of Tail Recursion in \textsc{Prolog} Programs. 

\item Able to recognize and work with all kinds of lists supported by \textsc{Prolog}.

\item Anything else ???????????????
\end{enumerate}
\end{comment}

\end{document}